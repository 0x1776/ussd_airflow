"""

"""
from urllib.parse import unquote
from copy import copy, deepcopy
from rest_framework.views import APIView
from django.contrib.sessions.backends.db import \
    SessionStore as DjangoSessionStore


class UssdRequest(object):

    def __init__(self, session_id, phone_number,
                 ussd_input, ussd_yml_namespace,
                 session=None, **kwargs):
        """Represents a USSD request"""

        self.phone_number = phone_number
        self.session_id = session_id
        self.input = unquote(ussd_input)
        self.session = session
        self.ussd_yml_namespace = ussd_yml_namespace

        for key, value in kwargs.items():
            setattr(self, key, value)


        def forward(self, handler_name):
            """
            Forwards a copy of the current request to a new
            handler. Clears any input, as it is assumed this was meant for
            the previous handler. If you need to pass info between
            handlers, do it through the USSD session.
            """
            new_request = copy(self)
            new_request.input = ''
            return new_request, handler_name

        def loging_params(self):
            all_variables = deepcopy(self.__dict__)

            # delete session if it exist
            all_variables.pop("session", None)

            return all_variables


def validate_ussd_journey(ussd_content):
    pass


class UssdView(APIView):
    pass


class SessionStore(DjangoSessionStore):
    """
    HACK! HACK! HACK!

    Django's built-in session store silently replaces user-provided
    session keys with autogenerated ones to prevent session fixation
    attacks. While this is a security best practice, it leaves us with
    no way to interact with cookie-less USSD gateways that do not
    offer a pass-through HTTP variable, since we have no way to send
    them our own autogenerated session key.

    This subclass is a hack that allows us to work with user-provided
    session keys. One side effect of this is that multiple session
    model objects may be created, though only one will save the actual
    updates.
    """

    def __init__(self, session_key):
        """
        Call parent init method, then save the gateway-provided
        session key.
        """
        super(SessionStore, self).__init__(session_key)
        self.user_session_key = session_key

    def save(self, *args, **kwargs):
        """
        Restore the gateway-provided session key, then call parent
        save method.
        """
        self._session_key = self.user_session_key
        super(SessionStore, self).save(*args, **kwargs)